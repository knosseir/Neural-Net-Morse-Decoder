//--------------------------------------------------------------------
//		Timescale
//		Means that if you do #1 in the initial block of your
//		testbench, time is advanced by 1ns instead of 1ps
//--------------------------------------------------------------------
`timescale 1ns / 1ps

//--------------------------------------------------------------------
//		Design assignment #2, problem #1 sample testbench.
//--------------------------------------------------------------------
module dassign3_1_tb();

//----------------------------------------------------------------
//		Signal Declarations
//----------------------------------------------------------------

// clock
wire clk, wdog;
reg wdog_rst;

// inputs to adder
reg [15:0]   a, b, c, d, e;
reg          valid;

// inputs to neuron
reg signed [7:0]   w1, w2, w3, w4, bb;
reg [7:0]   x1, x2, x3, x4;
reg signed [8:0]   sx1, sx2, sx3, sx4;

// output generated by relu
wire [7:0] relu_a;

// outputs generated by adder
wire[15:0]  sum;
wire        ready_sum;

// outputs generated by neuron
wire[7:0]   y;
wire        ready_neuron;

// variables for testing
integer     i;
reg[15:0]   correct_sum;
integer     raw_neuron;
reg[7:0]    correct_neuron;
integer     relu_err, sum_err, neuron_err;

//----------------------------------------------------------------
//		Instantiate modules 
//----------------------------------------------------------------
clock_gen     clock_gen(clk);
watchdog_gen  watchdog_gen(clk, wdog_rst, wdog);
piped_adder   piped_adder(clk, a, b, c, d, e, valid, sum, ready_sum);
relu          relu(a, relu_a);
neuron        neuron(clk, w1, w2, w3, w4, bb, x1, x2, x3, x4, valid, y, ready_neuron);

//----------------------------------------------------------------
//		Test Stimulus
//----------------------------------------------------------------
initial begin
    // Export timing information
    // Warning: slow!
    // $dumpfile("timing3_1.vcd");
    // $dumpvars;

    // Number of errors detected
    relu_err = 0;
    sum_err = 0;
    neuron_err = 0;

    @(posedge clk);
    wdog_rst = 1;

    for(i=8'b0; i<255; i=i+1) begin
        // Wait for rising edge of clock
        @(posedge clk); #1
        wdog_rst = 0;

        // set inputs to random values
        // and tell the adder they're valid
        a = $urandom;
        b = $urandom;
        c = $urandom;
        d = $urandom;
        e = $urandom ;

        // range of -40 to 40
        w1 = $random / 53554432;
        w2 = $random / 53554432;
        w3 = $random / 53554432;
        w4 = $random / 53554432;
        bb = $random / 53554432;

        x1 = $urandom;
        x2 = $urandom;
        x3 = $urandom;
        x4 = $urandom;
        valid = 1'b1;

        correct_sum = a+b+c+d+e;
        sx1 = x1;
        sx2 = x2;
        sx3 = x3;
        sx4 = x4;
        raw_neuron = (w1*sx1 + w2*sx2 + w3*sx3 + w4*sx4 + bb);
        if (raw_neuron > 0)
          correct_neuron = raw_neuron/4;
        else
          correct_neuron = 0;

        // Wait for next rising edge of clock
        // check ReLU
        // then clear inputs 
        @(posedge clk); 
        if (relu_a !== (a[15] ? 8'b0 : a[9:2]))
          relu_err = relu_err + 1;

		#1
        a = 16'b0;
        b = 16'b0;
        c = 16'b0;
        d = 16'b0;
        e = 16'b0;
        valid = 1'b0;

        // Wait until sum indicates ready
        // then check output
        @(posedge ready_sum or posedge wdog);
        @(posedge clk);

        if (wdog)
          $display("Watchdog! (adder)");
        if(sum !== correct_sum || ready_sum !== 1'b1) begin
            sum_err=sum_err+1;
                    $display("error: %b", sum_err);

        end

        #1 wdog_rst = 1;
        @(posedge clk); #1 wdog_rst = 0;

        // Wait until neuron indicates ready
        // then check output
        @(posedge ready_neuron or posedge wdog);
        @(posedge clk);

        if (wdog)
            $display("Watchdog! (neuron)");
        if(y !== correct_neuron || ready_neuron !== 1'b1) begin
            neuron_err=neuron_err+1;
        end

        #1 wdog_rst = 1;

    end

    $display("ASSERTION 3.1(a) : relu ERRNO %d",relu_err);
    $display("ASSERTION 3.1(b) : piped_adder ERRNO %d",sum_err);
    $display("ASSERTION 3.1(c) : neuron ERRNO %d",neuron_err);

    $finish;
end
endmodule

// Clock generation.  Period set via parameter:
//   clock changes every half_period ticks
//   full clock period = 2*half_period
module clock_gen(clk);
    parameter half_period = 31; 
    output clk;
    reg    clk;

    initial clk = 1;
    always #half_period clk = ~clk;
endmodule

module watchdog_gen(clk, rst, wdog);
    input clk, rst;
    output wdog;
    reg    wdog;

    reg [31:0] cnt = 0;

    always @(posedge clk) begin
      cnt <= rst ? 0 : cnt + 1;
      wdog <= (cnt > 50000);
    end	
endmodule
